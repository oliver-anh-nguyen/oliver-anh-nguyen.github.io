{"status":"ok","feed":{"url":"https://medium.com/feed/@oliver-nguyen","title":"Stories by Oliver Nguyen on Medium","link":"https://medium.com/@oliver-nguyen?source=rss-e2406be0efc8------2","author":"","description":"Stories by Oliver Nguyen on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*xnLZyNMIZGqJ21TPg10Hww.jpeg"},"items":[{"title":"Deploy Nodejs to Heroku with subfolder on Github","pubDate":"2022-08-06 16:42:03","link":"https://oliver-nguyen.medium.com/deploy-nodejs-to-heroku-with-subfolder-in-github-cb535cf85a5b?source=rss-e2406be0efc8------2","guid":"https://medium.com/p/cb535cf85a5b","author":"Oliver Nguyen","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*UCvlIc9cnToF4jvuyDrxpw.png","description":"\n<p>Step-by-step how to deploy Nodejs code to Heroku with subfolder in\u00a0Github</p>\n<p>Create account at Heroku: <a href=\"https://www.heroku.com/\">https://www.heroku.com</a></p>\n<p>Sample subfolder in\u00a0Github</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UCvlIc9cnToF4jvuyDrxpw.png\"><figcaption>folder server contains nodejs\u00a0code</figcaption></figure><h3>Nodejs</h3>\n<h4>package.json</h4>\n<a href=\"https://medium.com/media/7e4d0d3e9f4900f4dae6bf621bc095f6/href\">https://medium.com/media/7e4d0d3e9f4900f4dae6bf621bc095f6/href</a><h4>app.js</h4>\n<a href=\"https://medium.com/media/f61a10a1510657fbc745a88836257ca8/href\">https://medium.com/media/f61a10a1510657fbc745a88836257ca8/href</a><h3>Heroku: go to Settings\u00a0tab</h3>\n<h4>Buildpacks</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*05HvqG0eicOneuXRXL7cvw.png\"><figcaption>add <a href=\"https://github.com/timanovsky/subdir-heroku-buildpack.git\">https://github.com/timanovsky/subdir-heroku-buildpack.git</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5RZpfsctmVD3qk-o71U3RQ.png\"><figcaption>add nodejs</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqpd-jitXzK6ilwhqF6csQ.png\"><figcaption>after finished</figcaption></figure><h4>Config Vars</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EZOdJMhm4dsIa2uDeDpMtQ.png\"><figcaption>add PROJECT_PATH with subfolder on\u00a0Github</figcaption></figure><p>Last but not least, deploy and testing. Have\u00a0fun!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cb535cf85a5b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Step-by-step how to deploy Nodejs code to Heroku with subfolder in\u00a0Github</p>\n<p>Create account at Heroku: <a href=\"https://www.heroku.com/\">https://www.heroku.com</a></p>\n<p>Sample subfolder in\u00a0Github</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UCvlIc9cnToF4jvuyDrxpw.png\"><figcaption>folder server contains nodejs\u00a0code</figcaption></figure><h3>Nodejs</h3>\n<h4>package.json</h4>\n<a href=\"https://medium.com/media/7e4d0d3e9f4900f4dae6bf621bc095f6/href\">https://medium.com/media/7e4d0d3e9f4900f4dae6bf621bc095f6/href</a><h4>app.js</h4>\n<a href=\"https://medium.com/media/f61a10a1510657fbc745a88836257ca8/href\">https://medium.com/media/f61a10a1510657fbc745a88836257ca8/href</a><h3>Heroku: go to Settings\u00a0tab</h3>\n<h4>Buildpacks</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*05HvqG0eicOneuXRXL7cvw.png\"><figcaption>add <a href=\"https://github.com/timanovsky/subdir-heroku-buildpack.git\">https://github.com/timanovsky/subdir-heroku-buildpack.git</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5RZpfsctmVD3qk-o71U3RQ.png\"><figcaption>add nodejs</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqpd-jitXzK6ilwhqF6csQ.png\"><figcaption>after finished</figcaption></figure><h4>Config Vars</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EZOdJMhm4dsIa2uDeDpMtQ.png\"><figcaption>add PROJECT_PATH with subfolder on\u00a0Github</figcaption></figure><p>Last but not least, deploy and testing. Have\u00a0fun!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cb535cf85a5b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["deploy-heroku","nodejs","github"]},{"title":"Some tips in Flutter","pubDate":"2020-11-25 05:31:53","link":"https://oliver-nguyen.medium.com/some-tips-in-flutter-33a63e28505?source=rss-e2406be0efc8------2","guid":"https://medium.com/p/33a63e28505","author":"Oliver Nguyen","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33a63e28505","description":"\n<p>Android Studio\u00a04.1+</p>\n<p>Issues:</p>\n<pre>\u2717 Flutter plugin not installed; this adds Flutter specific functionality.<br>\u2717 Dart plugin not installed; this adds Dart specific functionality.</pre>\n<p>Solved by this\u00a0command:</p>\n<blockquote><strong>ln -s ~/Library/Application\\ Support/Google/AndroidStudio4.1/plugins ~/Library/Application\\ Support/AndroidStudio4.1</strong></blockquote>\n<p>Install</p>\n<p>Open or create\u00a0<strong><em>.bash_profile</em></strong></p>\n<blockquote><strong>nano ~/.bash_profile</strong></blockquote>\n<p>Edit and\u00a0insert</p>\n<blockquote><strong>export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH</strong></blockquote>\n<p>e.g: <strong><em>export PATH=~/Documents/flutter/bin:$PATH</em></strong></p>\n<p>Save and verify by running: <strong><em>echo\u00a0$PATH</em></strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=33a63e28505\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Android Studio\u00a04.1+</p>\n<p>Issues:</p>\n<pre>\u2717 Flutter plugin not installed; this adds Flutter specific functionality.<br>\u2717 Dart plugin not installed; this adds Dart specific functionality.</pre>\n<p>Solved by this\u00a0command:</p>\n<blockquote><strong>ln -s ~/Library/Application\\ Support/Google/AndroidStudio4.1/plugins ~/Library/Application\\ Support/AndroidStudio4.1</strong></blockquote>\n<p>Install</p>\n<p>Open or create\u00a0<strong><em>.bash_profile</em></strong></p>\n<blockquote><strong>nano ~/.bash_profile</strong></blockquote>\n<p>Edit and\u00a0insert</p>\n<blockquote><strong>export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH</strong></blockquote>\n<p>e.g: <strong><em>export PATH=~/Documents/flutter/bin:$PATH</em></strong></p>\n<p>Save and verify by running: <strong><em>echo\u00a0$PATH</em></strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=33a63e28505\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["flutter","android-studio-4","flutter-install"]},{"title":"Some tips in Swift","pubDate":"2020-07-17 08:00:40","link":"https://oliver-nguyen.medium.com/some-tips-in-swift-a4abfe381a3f?source=rss-e2406be0efc8------2","guid":"https://medium.com/p/a4abfe381a3f","author":"Oliver Nguyen","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a4abfe381a3f","description":"\n<p>Copy-on-Right</p>\n<p>This problem is solved using copy on write: when you point two variables at the same array they both point to the same underlying data. Swift promises that structs like arrays and dictionaries are copied as values, like numbers, so having two variables point to the same data might seem to contradict that. The solution is simple but clever: if you modify the second variable, Swift takes a full copy at that point so that only the second variable is modified\u200a\u2014\u200athe first isn\u2019t\u00a0changed.</p>\n<pre>let array1: [Int] = [0, 1, 2, 3]<br>var array2 = array1 </pre>\n<pre>//Print with just assign<br>print(address: array1) //0x600000078de0<br>print(address: array2) //0x600000078de0</pre>\n<pre>//Let's mutate array2 to see what's<br>array2.append(4) </pre>\n<pre>print(address: array2) //0x6000000aa100 </pre>\n<pre>//Output<br>//0x600000078de0 array1 address<br>//0x600000078de0 array2 address before mutation<br>//0x6000000aa100 array2 address after mutation</pre>\n<p>Print</p>\n<p>How to print memory of variable in\u00a0swift</p>\n<pre>func print(address o: UnsafeRawPointer ) {    <br>    print(String(format: \"%p\", Int(bitPattern: o)))<br>}</pre>\n<pre>let array: [Int] = [0, 1, 2, 3]</pre>\n<pre>print(address: array)</pre>\n<pre>//Output<br>//0x600000078de0 array address</pre>\n<p><strong>SwiftLint</strong></p>\n<p>If you want only show <strong>warnings</strong>, convert all <strong>errors</strong> to <strong>warnings</strong>, just add in Build\u00a0Phases</p>\n<pre>sed s/error:/warning:/g</pre>\n<p>e.g with\u00a0Pod</p>\n<blockquote>${SRCROOT}/StaticPod/Pods/SwiftLint/swiftlint | sed s/error:/warning:/g</blockquote>\n<p><strong>Design Pattern</strong></p>\n<h4><strong>Singleton</strong></h4>\n<pre>class Singleton { <br>   static let shared: Singleton = Singleton() <br>}</pre>\n<p>Should write simple like\u00a0that.</p>\n<blockquote>\n<strong>Swift </strong>is a<strong> static languge </strong>so variable/ function/ class marked <strong>static</strong> will<strong> </strong>init at <strong>compile-time. </strong>However<strong>, static let</strong> is <strong>global variables </strong>so it<strong> </strong>is a property whose initial value is not calculated until the first time it is used (like\u00a0<strong>lazy</strong>)</blockquote>\n<p>Stack</p>\n<p>Stack is tightly managed and <strong>optimized</strong> by the CPU. When a function creates a variable, the stack <strong>stores</strong> that variable and is <strong>destroyed</strong> when the function <strong>exits</strong>. Variables allocated on the stack are <em>stored directly to the memory</em> and <em>access to this memory is very fast</em>. When a function or a method calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer. Since the stack is very well organized, it is very <strong>efficient</strong> and\u00a0<strong>fast</strong>.</p>\n<p>Heap</p>\n<p>The system uses the heap to store data <strong>referenced</strong> by other objects. The heap is generally a large pool of memory from which the system can request and dynamically allocate blocks of memory. <em>The heap doesn\u2019t automatically destroy its object like the stack does</em>. External work has to be done to do this. <strong>ARC</strong> does the job in apple devices. Reference count is tracked by the <strong>ARC</strong> and when it becomes <strong>zero</strong>, the object is <strong>deallocated</strong>. Hence, the overall process (allocation\u00a0, tracking the references and deallocation) is slower compared to stack. <em>So value types are faster than reference types.</em></p>\n<p>UIView</p>\n<p>If you want to set <strong>cornerRadius </strong>for only <strong>top-left</strong> and <strong>top-right</strong> corner of a\u00a0<strong><em>UIView</em></strong></p>\n<pre>func roundCornerRadius(corners: UIRectCorner, radius: CGFloat)    {</pre>\n<pre>   let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))</pre>\n<pre>   let mask = CAShapeLayer()</pre>\n<pre>   mask.path = path.cgPath</pre>\n<pre>   self.layer.mask = mask</pre>\n<pre>}</pre>\n<pre>if #available(iOS 11.0, *) {</pre>\n<pre>   view.layer.cornerRadius = 4.0</pre>\n<pre>   view.layer.maskedCorners = [.layerMinXMinYCorner,          .layerMaxXMinYCorner]</pre>\n<pre>} else {</pre>\n<pre>   view.roundCornerRadius(corners: [.topLeft, .topRight], radius: 4.0)</pre>\n<pre>}</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a4abfe381a3f\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Copy-on-Right</p>\n<p>This problem is solved using copy on write: when you point two variables at the same array they both point to the same underlying data. Swift promises that structs like arrays and dictionaries are copied as values, like numbers, so having two variables point to the same data might seem to contradict that. The solution is simple but clever: if you modify the second variable, Swift takes a full copy at that point so that only the second variable is modified\u200a\u2014\u200athe first isn\u2019t\u00a0changed.</p>\n<pre>let array1: [Int] = [0, 1, 2, 3]<br>var array2 = array1 </pre>\n<pre>//Print with just assign<br>print(address: array1) //0x600000078de0<br>print(address: array2) //0x600000078de0</pre>\n<pre>//Let's mutate array2 to see what's<br>array2.append(4) </pre>\n<pre>print(address: array2) //0x6000000aa100 </pre>\n<pre>//Output<br>//0x600000078de0 array1 address<br>//0x600000078de0 array2 address before mutation<br>//0x6000000aa100 array2 address after mutation</pre>\n<p>Print</p>\n<p>How to print memory of variable in\u00a0swift</p>\n<pre>func print(address o: UnsafeRawPointer ) {    <br>    print(String(format: \"%p\", Int(bitPattern: o)))<br>}</pre>\n<pre>let array: [Int] = [0, 1, 2, 3]</pre>\n<pre>print(address: array)</pre>\n<pre>//Output<br>//0x600000078de0 array address</pre>\n<p><strong>SwiftLint</strong></p>\n<p>If you want only show <strong>warnings</strong>, convert all <strong>errors</strong> to <strong>warnings</strong>, just add in Build\u00a0Phases</p>\n<pre>sed s/error:/warning:/g</pre>\n<p>e.g with\u00a0Pod</p>\n<blockquote>${SRCROOT}/StaticPod/Pods/SwiftLint/swiftlint | sed s/error:/warning:/g</blockquote>\n<p><strong>Design Pattern</strong></p>\n<h4><strong>Singleton</strong></h4>\n<pre>class Singleton { <br>   static let shared: Singleton = Singleton() <br>}</pre>\n<p>Should write simple like\u00a0that.</p>\n<blockquote>\n<strong>Swift </strong>is a<strong> static languge </strong>so variable/ function/ class marked <strong>static</strong> will<strong> </strong>init at <strong>compile-time. </strong>However<strong>, static let</strong> is <strong>global variables </strong>so it<strong> </strong>is a property whose initial value is not calculated until the first time it is used (like\u00a0<strong>lazy</strong>)</blockquote>\n<p>Stack</p>\n<p>Stack is tightly managed and <strong>optimized</strong> by the CPU. When a function creates a variable, the stack <strong>stores</strong> that variable and is <strong>destroyed</strong> when the function <strong>exits</strong>. Variables allocated on the stack are <em>stored directly to the memory</em> and <em>access to this memory is very fast</em>. When a function or a method calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer. Since the stack is very well organized, it is very <strong>efficient</strong> and\u00a0<strong>fast</strong>.</p>\n<p>Heap</p>\n<p>The system uses the heap to store data <strong>referenced</strong> by other objects. The heap is generally a large pool of memory from which the system can request and dynamically allocate blocks of memory. <em>The heap doesn\u2019t automatically destroy its object like the stack does</em>. External work has to be done to do this. <strong>ARC</strong> does the job in apple devices. Reference count is tracked by the <strong>ARC</strong> and when it becomes <strong>zero</strong>, the object is <strong>deallocated</strong>. Hence, the overall process (allocation\u00a0, tracking the references and deallocation) is slower compared to stack. <em>So value types are faster than reference types.</em></p>\n<p>UIView</p>\n<p>If you want to set <strong>cornerRadius </strong>for only <strong>top-left</strong> and <strong>top-right</strong> corner of a\u00a0<strong><em>UIView</em></strong></p>\n<pre>func roundCornerRadius(corners: UIRectCorner, radius: CGFloat)    {</pre>\n<pre>   let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))</pre>\n<pre>   let mask = CAShapeLayer()</pre>\n<pre>   mask.path = path.cgPath</pre>\n<pre>   self.layer.mask = mask</pre>\n<pre>}</pre>\n<pre>if #available(iOS 11.0, *) {</pre>\n<pre>   view.layer.cornerRadius = 4.0</pre>\n<pre>   view.layer.maskedCorners = [.layerMinXMinYCorner,          .layerMaxXMinYCorner]</pre>\n<pre>} else {</pre>\n<pre>   view.roundCornerRadius(corners: [.topLeft, .topRight], radius: 4.0)</pre>\n<pre>}</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a4abfe381a3f\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["swift","swiftlint"]}]}